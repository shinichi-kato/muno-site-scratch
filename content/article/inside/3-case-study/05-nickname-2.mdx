---
title: "名付けボット(2)"
color: "secondary"
updated: "2022-08-14T12:00Z"
featuredImage: "./railroad-diagram.png"
tags: 
    - "Pattern Encoder"
    - "Naming State Machine"
    - "Tag Decoder"
---

 **本ページは現在推敲中です**

## 会話の中でのユーザによるチャットボットの名付け手続き

<Chatbot source='/chatbot/namer'/>

ユーザがチャットボットにニックネームを付けるときの会話の流れとして、次のような想定をします。
ニックネームの提案とみなせるユーザのセリフにはいろいろなパターンがあります。それらに「naming」という内部コードを割り当てます。
同様にニックネームの確認はconfirm、承諾し、記憶したらmemorized、中止はbreakとします。以下の例ではそれを末尾にカッコ書きで表しました。

```
モデル会話 1
しずく(bot): userさん、今日は楽しかったです!
user: ねえ、しずって呼んでいい？ (naming)
bot: 私にニックネームを付けてくれるんですか？いいですよ！しずですね！ (confirm)
user: ありがとう!
bot: しずと呼んでください(memorized)

モデル会話 2
user: しずくのこと、ももって呼んでいい？ (naming)
bot: 私にニックネームを付けてくれるんですか？もですね！ (confirm)
user: ちがう！もも！
bot: ももですね(confirm)
user: そう！
bot: はーい(memorized)

モデル会話 3
user: ももって呼んでいい？ (naming)
bot: もですね！ (confirm)
user: うーん、やっぱやめた
bot: なーんだ(break)
```

モデル会話を整理して内部コードで記述してみると次のようになります。ユーザによるnamingの次にチャットボットがconfirmします。
confirmへの返答が肯定的だった場合はだった場合、チャットボットはmemorizedを出力して通常の会話に戻ります。
confirmへの返答に再び名前が含まれる場合はconfirmに戻ります。
ユーザの反応がチャットボットの期待したものであればこのダイアグラムにそって処理が進みますが、そうでなかった場合も考えます。

```
NG会話 1
user: ももって呼んでいい？ (namig)
bot: ももですね！ (confirm)
user: 今日はいい天気だよね (?)
bot: 
...


いきなり違う話題を振られたら、やんわりとしたキャンセルと見て良さそうです。つまり明確な同意以外は基本的にキャンセル扱いとし、「cancel」という返答をわざわざ設定するのはやめます。
これらをrailroad diagramに表したものをFig.1 に示します。Fig. 1には**main**と**naming**という2つのダイアグラムがあり、mainダイアグラムの中でnamingダイアグラムを利用しています。
namingダイアグラムのほうが名前付け手続きの本体で、それ以外の会話にも対応できるようにしたのがmainダイアグラムです。
図中で`'*'`としてあるのはどの内部コードにも帰属されなかったユーザの発言で、その場合は通常の返答を行います。

![Fig. 1. 名付けの流れ](./naming-diagram.png)

以上をチャットボットのシステムとしてまとめると、各モジュールには次のような機能が必要になります。

1. エンコーダー: ユーザ入力のうち名前を抽出する
2. 内的プロセス: 内部状態を保持し、Fig.1に従って次の動作を決める
3. デコーダー: タグで指定された名前を展開する

### 名前を抽出するエンコーダー

これまでに用意したBag-of-WordエンコーダーやBag-of-Phraseエンコーダーは文字列を形態素や文節に区切って利用しましたが、どちらもあまり区切りの精度が高いとは言えません。
さらにニックネームでは響きも重要な要素なので、オノマトペ的な文字列が使われたりもします。
その場合には形態素や文節区切りが難しいので、ニックネーム抽出に限り`*って呼んでいい`のような固定的なパターンを用いた識別が必要になるでしょう。
パターンを使うことでテキスト検索の柔軟性は低下しますが、エンコーダーの用途を限定して対処します。

### 状態遷移を行う内部プロセス

Fig.1で示したダイアグラムに沿って状態を管理する状態機械を作ります。


### タグを展開するデコーダー
ユーザやチャットボットの名前は永続的に記憶する必要があります。


## 会話の中でのチャットボットによる名付けの手続き

チャットボットがユーザにニックネームを付ける手続きの内容を見てみます。

```
モデル会話 4
bot: userさんのことをなんて呼んだらいいですか？(query)
user: えーっと、しまりすって呼んで？ (answer)
bot: しまりすさんですね！(confirm)
user: そうそう。(agree)

モデル会話 5
bot: userさんのこと、森の賢者って呼んでいいですか？(query)
user: え・・・なにそれ(*)
bot: ...
```
ユーザにニックネームを聞く場合はおそらくFig.1の鏡写しのようなダイアグラムとなり、問題なさそうです。一方でチャットボットがユーザの名前を考える方は色々課題がありそうです。
まず名前を決めるのに、ランダムなテキスト生成を使うとユーザの属性と無関係になる可能性が高く、あまり受け入れられる名前ができなさそうです。
ユーザの発言から最頻出単語を選ぶ方法などがあるかもしれませんが、これは概念形成という課題になると思われます。


## 不在時に呼びかけたら現れる
ユーザ入力冒頭の「おーい」「ねえ」などは一般的なテキスト系機械学習では計算前に除外すべきワード(STOP WORDS)とされがちです。
ところが人間同士の会話では「おーい」だけでも誰かの注意を向ける、会話に参加していない誰かを呼ぶ、といった機能を持った完結した文であるとみなすべきです。
また「チャットボットの不在」という状態をつくり、呼びかけによって「チャットボットが現れる」というアクションをユーザに見せることができれば、ユーザはチャットボットが意図を理解しているという実感を得られるでしょう。
チャットボットが在室だったり不在だったりすると、「いない間チャットボットはどうしてるんだろう」など想像を広げることもできます。

```
モデル会話 6
bot: ※不在
user: しず〜 (summon)
bot: はーい
```
チャットの開始時には不在の可能性があり、呼び出せば在室状態になる、というロジックをFig. 1に追加するとFig. 2のようになります。
「stand-by」のループでは不在なので何も返事をしません。ユーザがsummon(召喚)にあたる入力をした場合のみそれに応答して在室状態に移行します。

![Fig. 2. 不在・在室状態のある状態機械](./naming-diagram2.png)

このsummonの判定をするときに記憶したニックネームが有効である必要があります。そのためにはencoderでチャットボットの名前やニックネームをあらかじめタグに置き換える処理をしておきます。

